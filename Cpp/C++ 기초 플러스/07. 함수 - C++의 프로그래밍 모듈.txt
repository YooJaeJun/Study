
배열은 리턴값으로 사용할 수 없다.
- 함수가 배열을 직접 리턴할 수는 없지만, 구조체나 객체의 일부로 되어 있는 배열은 리턴할 수 있다.

함수 원리
- 자신의 리턴값을 CPU의 지정된 레지스터나 메모리에 복사하는 방법으로 리턴
- 함수를 호출한 프로그램이 그 위치에 무엇이 있는지 조사한다.
    - 그러므로 리턴하는 함수와 호출하는 함수는 그 위치에 놓을 값의 데이터형을 서로 일치시켜야 한다.
- 함수 원형은 호출한 프로그램에게 그 위치에 어떤 데이터형이 놓일지 알려준다.

함수 원형
- 컴파일러에게 함수의 인터페이스를 알려준다.
- 즉, 리턴값이 있으면 그 리턴값의 데이터형을 컴파일러에게 알려준다.

C++와 ANSI C의 함수 원형 비교
- void a();
    - C++: void. 함수가 어떠한 매개변수도 요구하지 않는다.
    - ANSI C: 매개변수 리스트가 무엇인지 확인하지 않겠다.
        - C++에서 이 의미는 void a(...); 와 같이 생략 부호(ellipsis) 사용
        
함수 원형의 보장
- 컴파일러가 함수의 리턴값을 바르게 처리한다.
- 사용자가 정확한 개수의 매개변수를 사용했는지 컴파일러가 검사한다.
- 사용자가 정확한 데이터형의 매개변수를 사용했는지 컴파일러가 검사한다.
    - 사용자가 정확한 데이터형을 사용하지 않았다면, 컴파일러가 정확한 데이터형으로 변환한다.

매개변수의 개수는 맞지만 데이터형이 불일치하는 경우
- 함수 원형에 정의되어 있는 데이터형으로 자동 변환

//
직접 실험 결과
- 리턴 타입이나 매개변수 타입이 선언부와 정의부가 맞지 않으면, 링크 에러 뜸
//


형식 매개변수 (formal parameter)
- 전달되는 값을 넘겨받는 데 쓰이는 변수

실제 매개변수 (actual argument)
- 함수에 전달되는 값

=> 함수에 매개변수를 전달하는 것은 argument를 parameter에 대입하는 것


lotto 예제

```
#include <iostream>
using namespace std;

long double probability(unsigned numbers, unsigned picks);

int main()
{
	double total, choices;
	cout << "전체 수의 개수, 뽑을 수의 개수 입력: ";
	while ((cin >> total >> choices) && choices <= total)
	{
		cout << "당신이 이길 확률은 ";
		cout << probability(total, choices);	// 승률을 계산한다.
		cout << " 번 중에서 한 번입니다. \n";
		cout << "다시 두 수를 입력하십시오. (끝내려면 q를 입력): ";
	}
	cout << "프로그램 종료.\n";
	return 0;
}

long double probability(unsigned numbers, unsigned picks)
{
	long double result = 1.0;
	long double n;
	unsigned p;

	for (n = numbers, p = picks; p > 0; n--, p--)
		result = result * n / p;
	return result;
}
```



03. 함수와 배열

```
int sum_arr(int arr[], int n)
```

// 되새기기
- arr은 배열이 아닌 포인터
- 배열 이름은 첫 번째 원소의 주소
- &arr은 전체 배열 주소

- arr[i] == *(arr + i)
- &arr[i] == arr + i


함수 매개변수로 쓰인 배열(사실 포인터) 예제

```
#include <iostream>
using namespace std;

int sumArr(int arr[], int n);

int main()
{
	const int arSize = 8;
	int cookies[arSize] = { 1,2,4,8,16,32,64,128 };
	cout << cookies << " = 배열주소, ";
	cout << "sizeof cookies = " << sizeof cookies << endl;

	int sum = sumArr(cookies, arSize);
	cout << "먹은 과자 수 합계: " << sum << endl;
	sum = sumArr(cookies, 3);
	cout << "처음 세 사람은 과자 " << sum << "개를 먹었습니다.\n";
	sum = sumArr(cookies + 4, 4);
	cout << "마지막 네 사람은 과자 " << sum << "개를 먹었습니다.\n";
	
	return 0;
}

int sumArr(int arr[], int n)
{
	int total = 0;
	cout << arr << " = arr, ";
	cout << "sizeof arr = " << sizeof arr << endl;
	for (int i = 0; i < n; i++)
		total += arr[i];
	return total;
}
```
```
0000009028EFFC18 = 배열주소, sizeof cookies = 32
0000009028EFFC18 = arr, sizeof arr = 8
먹은 과자 수 합계: 255
0000009028EFFC18 = arr, sizeof arr = 8
처음 세 사람은 과자 7개를 먹었습니다.
0000009028EFFC28 = arr, sizeof arr = 8
마지막 네 사람은 과자 240개를 먹었습니다.
```

cookies 사이즈는 32, arr 사이즈는 8
- 배열 전체의 크기, 포인터 변수의 크기


const
- const double ar[] == const double * ar
- 원본 배열의 값을 변경할 목적이 없을 때 const T


const + 배열 범위 사용 예제

```
#include <iostream>
using namespace std;

int sumArr(const int* begin, const int* end);

int main()
{
	const int arSize = 8;
	int cookies[arSize] = { 1,2,4,8,16,32,64,128 };
	cout << cookies << " = 배열주소, ";
	cout << "sizeof cookies = " << sizeof cookies << endl;

	int sum = sumArr(cookies, cookies + arSize);
	cout << "먹은 과자 수 합계: " << sum << endl;
	sum = sumArr(cookies, cookies + 3);
	cout << "처음 세 사람은 과자 " << sum << "개를 먹었습니다.\n";
	sum = sumArr(cookies + 4, cookies + 8);
	cout << "마지막 네 사람은 과자 " << sum << "개를 먹었습니다.\n";
	
	return 0;
}

int sumArr(const int * begin, const int * end)
{
	const int* pt;
	int total = 0;

	for (pt = begin; pt != end; pt++)
		total += *pt;
	return total;
}
```
```
000000EAA377F5B8 = 배열주소, sizeof cookies = 32
먹은 과자 수 합계: 255
처음 세 사람은 과자 7개를 먹었습니다.
마지막 네 사람은 과자 240개를 먹었습니다.
```


const 포인터

const int* pt;
int* const pt;

const 변수의 주소를 const가 아닌 일반 포인터에 대입을 금지
- 꼭 하고 싶으면 const_cast 타입캐스팅

// 이건 블로그에도 따로 정리했음



4. 함수와 2차원 배열

```
int data[2][3] = {{1,2,3},{4,5,6}};
int total = sum(data, 2);
```
원형
```
int sum(int (*ar2)[4], int size);
int sum(int ar2[][4], int size);
```

int *ar2[4]
- 배열을 지시하는 포인터를 선언한 것이 아니라, int 값을 지시하는 포인터를 4개 가진 배열을 선언한 것

ar2[r][c] == *(*(ar2 + r) + c);



문자열 끝이 null 문자임을 이용해 검사하는 예제

```
#include <iostream>
using namespace std;

unsigned c_in_str(const char * str, char ch);

int main()
{
	char m[15] = "minimum";
	const char* u = "ululate";

	cout << c_in_str(m, 'm') << '\n';
	cout << c_in_str(u, 'u') << '\n';
	
	return 0;
}

unsigned c_in_str(const char* str, char ch)
{
	int count = 0;
	while (*str)    // 이거다!
	{
		if (*str == ch) count++;
		str++;
	}
	return count;
}
```
```
3
2
```



원점에서 거리와 각도를 구하는 프로그램 예제

```
#include <iostream>
#include <cmath>
using namespace std;

struct polar
{
	double distance, angle;
};
struct rectD
{
	double x, y;
};

polar rectToPolar(const rectD* pxy, polar* pda);
void showPolar(const polar* pda);

int main()
{
	rectD rplace;
	polar pplace;

	cout << "x값과 y값을 입력: ";
	while (cin >> rplace.x >> rplace.y)
	{
		pplace = rectToPolar(&rplace, &pplace);
		showPolar(&pplace);
		cout << "x값과 y값을 입력하십시오 (끝내려면 q 입력): ";
	}
	cout << "프로그램 종료.\n";
	return 0;
}

// 직각 좌표를 극 좌표로 변환
polar rectToPolar(const rectD* pxy, polar* pda)
{
	polar answer;
	answer.distance = sqrt(pxy->x * pxy->x + pxy->y * pxy->y);
	answer.angle = atan2(pxy->y, pxy->x);
	return answer;
}

// 라디안 단위를 도 단위로 변환하여 극 좌표를 출력한다.
void showPolar(const polar* pda)
{
	const double radToDeg = 57.2977951;
	
	cout << "거리 = " << pda->distance;
	cout << ", 각도 = " << pda->angle * radToDeg;
	cout << "도\n";
}
```

