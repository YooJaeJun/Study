
재활용

클래스 상속(class inheritance)


1. 간단한 기초 클래스로부터 시작하자

public 파생 (public derivation)
- 기초 클래스의 private 부분들도 파생 클래스의 일부가 되나,
- protected 메서드와 public 메서드를 통해서만 접근할 수 있다.


부모 클래스의 생성자는 멤버 초기화 리스트로
- 생략 시 기초 클래스의 암시적 복사 생성자 사용


파생 클래스와 기초 클래스의 특별한 관계

- 기초 클래스 포인터는 명시적 데이터형 변환 없이도 파생 클래스 객체를 지시할 수 있다.
- 기초 클래스 참조는 명시적 데이터형 변환 없이도 파생 클래스 객체를 참조할 수 있다.

```
Child rplayer1(1140, "Mallory", "Duck", true);
Parent& rt = rplayer1;
Parent* pt = &rplayer1;
rt.Name();
pt->Name();


Parent player("asdf", "zxcv", true);
Child& rr = player;		// 허용 안됨
Child* pr = player;	// 허용 안됨
```

- 파생 클래스 참조는 기초 클래스 객체를 위해 파생 클래스 메서드를 호출하는데,
- 기초 클래스는 파생 클래스의 메서드를 가지고 있지 않기 때문에 문제.

- 기초 클래스 객체를 지시하는 포인터를 형식 매개변수로 사용하는 함수에
- 기초 or 파생 클래스 객체 주소 사용 가능

```
void wohs(const Parent* pt);

Parent player1();
Child rplayer1();
wohs(&player1);		// Parent* 매개변수
wohs(&rplayer1);	// Child* 매개변수
```

- 이와 같은 참조 호환성은 기초 클래스 객체를 파생 클래스 객체로 초기화하는 것도 간접적으로 허용
```
Child olaf1();
Parent olaf2(olaf1);			// Parent(const Child&);	// 존재하지 않음
```

- 이 경우 대신 암시적인 복사 생성자가 그 역할을 대신함

```
Parent(const Parent&);
```

- 기초 클래스형에 대한 참조. 따라서 파생 클래스 형을 참조할 수 있다.

- 같은 논리로, 파생 클래스 객체를 기초 클래스 객체에 대입할 수 있다.
```
Child olaf1();
Parent winner;
winner = olaf1;		// 파생 클래스 객체를 기초 클래스 객체에 대입한다.
```

- 이 경우 다음 암시적인 오버로딩 대입 연산자 사용됨

```
Parent& operator=(const Parent&) const;
```

- 기초 클래스 참조가 파생 클래스 객체를 참조한다.
- olaf1의 기초 클래스 부분이 winner에 복사된다.




2. 상속: is-a 관계

- 기초 클래스를 대상으로 수행할 수 있는 모든 작업을, 파생 클래스 객체에 대해서도 수행할 수 있다.
- is-a-kind-of 관계. 보통 is-a 관계라 함


- has-a 관계 아님. "점심에 과일"
- is-like-a 관계 아님. "변호사는 상어다"
- i-implemented-as-a 관계 아님 "배열 - 스택"
- uses 관계 아님 "컴퓨터 - 프린트"




3. public 다형 상속

다형 (polymorhphic)

virtual 키워드
- 메서드가 객체에 의해 호출되지 않고 참조나 포인터에 의해 호출되었을 때
- 참조나 포인터에 의해 지시되는 객체형에 기초하여 메서드를 선택

예시 [생략]

가상 파괴자
- 파괴자들이 가상이 아니면, 포인터형에 해당하는 파괴자만 호출될 것
- 파괴자들이 올바른 순서로 호출되도록 한다.
- 자식에서 어떤 일을 하는 파괴자를 가질 경우, 
	- 아무 일도 하지 않는 파괴자라 하더라도 부모에 가상 파괴자를 제공해야 함




4. 정적 결합과 동적 결합

함수 호출
- 특정 블록에 있는 함수 코드를 실행
- "함수 이름을 결합(binding)한다."
- 컴파일러는 함수 이름, 매개변수 조사
- 컴파일하는 동안 일어나는 결합을 정적 결합(static binding) or 초기 결합(early binding)
- 가상 함수들은 실행 중 사용자가 객체를 결정
- 컴파일러는 프로그램을 실행할 때 올바른 가상 메서드가 선택되도록 해야한다.
- 동적 결합(dynamic binding) or 말기 결합(lately binding)


포인터와 참조형의 호환
- 일반적으로 한 데이터형의 주소를 다른 데이터형의 포인터에 대입하는 것을 허용하지 않는다.
- 참조도 마찬가지
- 그러나 기초 클래스를 지시하는 포인터나 참조는 명시적인 강제 데이터형 변환 업이도 파생 클래스 객체 참조
```
Child c();
Parent* pb = &c;
Parent& rb = &c;
```

업캐스팅 (upcasting)
- 파생 클래스 참조나 포인터를 기초 클래스 참조나 포인터로 변환하는 것
- public 상속에서는 명시적인 데이터형 변환이 없어도 업캐스팅이 언제든지 허용된다.
- 객체를 지시하는 포인터를 함수의 매개변수로 전달할 때에도 같은 논리 적용. 업캐스팅은 전이된다.
	- 파생 클래스로부터 또 다른 클래스를 파생시키면, 
	- 기초 클래스의 포인터는 기초 클래스 객체, 파생 클래스 객체, 또 다른 파생 클래스 객체를 모두 참조할 수 있다.

다운캐스팅 (downcasting)
- 기초 클래스 포인터나 참조를 파생 클래스 포인터나 참조로 변환하는 것
- 명시적인 데이터형 변환 없이 허용되지 않는다.
- 파생 클래스를 지시하는 포인터를 기초 클래스의 주소로 설정하고, 그 포인터를 사용하여 파생 클래스의 멤버함수를 호출하는 사고 발생


가상 멤버 함수와 동적 결합

```
Derived d;
Base* bp;
bp = &d;
bp->ViewAct();	// 어떤 버전 호출?
```

- 가상으로 선언하지 않으면 Base::ViewAct(); 호출. 정적 결합.
- 가상 함수 그 반대. 동적 결합.


왜 정적 결합이 디폴트?
- 포인터나 참조 객체 종류 추적 처리 부담
- 메서드를 다시 정의하지 않으면, 필요 없음


가상 함수 테이블
- 컴파일러가 각각의 객체에 숨겨진 멤버를 하나씩 추가
- 숨겨진 멤버는 함수의 주소들로 이루어진 배열을 지시하는 포인터를 저장
- 그 배열을 가상 함수 테이블 (virtual function table; vtbl)
- 가상 함수들의 주소 저장
- 파생 클래스가 가상 함수를 다시 정의하지 않으면, vtbl은 그 함수의 오리지널 버전의 주소 저장


생성자
- 생성자는 가상으로 상요할 수 없다.
- 파생 클래스 객체의 생성은, 기초 클래스 생성자가 아니라 파생 클래스 생성자를 호출한다.
	- 그러고 나서 파생 클래스 생성자가 기초 클래스 생성자를 사용한다.
- 그래서, 파생 클래스는 기초 클래스 생성자를 상속하지 않는다.


파괴자
- 클래스가 기초 클래스로 사용된다면, 파괴자는 가상으로 선언해야 한다.
- 예시 - Derived 클래스에서 char* 멤버 추가

```
Base* pe = new Derived;
delete pe;
```

- 디폴트 정적 결합 적용 시 ~Base() 파괴자 호출
- Base 성분들이 지시하는 메모리만 해제됨
- 그러므로 가상으로 선언하면 ~Derived() 파괴자 호출. 그 다음 ~Base() 호출

- 일반적으로, 파괴자가 필요 없는 기초 클래스라 하더라도 가상 파괴자를 제공해야 한다.


프렌드
- 프렌드는 가상 함수가 될 수 없다.
- 프렌드 함수가 내부적으로 가상 멤버 함수를 사용하게 할 순 있다.


가상 함수를 다시 정의하지 않으면
- 파생 클래스가 길게 이어진 파생 사슬의 일부라면,
	- 함수의 가상 최근에 정의된 버전 사용


가상 함수를 다시 정의하면 메서드가 은닉된다.

```
class Base
{
public:
	virtual void showperks(int a) const;
}
class Derived : public Base
{
public:
	virtual void showperks() const;
}
```

- 재정의는 int형 매개변수를 사용하는 기초 클래스 버전을 가린다.
- 즉, 상속된 메서드를 다시 정의하는 것은 오버로딩의 변종이 아니다.
- 재정의는 동일한 함수 시그내처를 가지고 있는 기초 클래스 선언만 가리는 것이 아니라, 
	- 매개변수 시그내처와는 상관 없이 같은 이름을 가진 모든 기초 클래스 메서드들을 가린다!!!


규칙
1. 상속된 메서드를 재정의할 경우, 오리지널 원형과 정확히 일치시킬 필요가 있다.
	- 예외: 리턴형이 기초 클래스에 대한 참조나 포인터인 경우, 파생 클래스에 대한 참조나 포인터로 대체될 순 있다.
	- 리턴형이 클래스형과 병행하여 바뀌는 것을 허용하기 때문에, 이 기능을
	- 리턴형의 공변(covariance)이라 한다.

```
class Base
{
public:
	virtual Derived& build(int n);
}
class Derived : public Base
{
public:
	// 공변 리턴형을 가지는 파생 메서드
	virtual Base& build(int n);			// 동일한 함수 시그내처
}
```

	- 이 예외는 매개변수가 아니라 리턴값에만 적용된다.

2. 기초 클래스 선언이 오버로딩되어 있다면, 파생 클래스에서 모든 기초 클래스 버전들을 재정의해야 한다.

```
class Base
{
public:
	virtual void A(int a) const;
	virtual void A(double x) const;
	virtual void A() const;
}
class Derived : public Base
{
public:
	virtual void A(int a) const;
	virtual void A(double x) const;
	virtual void A() const;
}
```

	- 한 가지 버전만 재정의하면, 나머지 두 버전은 가려져 파생 클래스 객체가 그들을 사용할 수 없게 된다.




5. 접근 제어: protected

- 가능하다면 protected 접근 제어보다 private 접근 제어 사용
- 기초 클래스 데이터에 접근하게 하려면 기초 클래스 메서드 사용




6. 추상화 기초 클래스 (abstract base class; ABC)

is-a 규칙 적용 어려움
- 원과 타원 그리는 프로그램
