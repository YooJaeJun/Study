
재활용

클래스 상속(class inheritance)


1. 간단한 기초 클래스로부터 시작하자

public 파생 (public derivation)
- 기초 클래스의 private 부분들도 파생 클래스의 일부가 되나,
- protected 메서드와 public 메서드를 통해서만 접근할 수 있다.


부모 클래스의 생성자는 멤버 초기화 리스트로
- 생략 시 기초 클래스의 암시적 복사 생성자 사용


파생 클래스와 기초 클래스의 특별한 관계

- 기초 클래스 포인터는 명시적 데이터형 변환 없이도 파생 클래스 객체를 지시할 수 있다.
- 기초 클래스 참조는 명시적 데이터형 변환 없이도 파생 클래스 객체를 참조할 수 있다.

```
Child rplayer1(1140, "Mallory", "Duck", true);
Parent& rt = rplayer1;
Parent* pt = &rplayer1;
rt.Name();
pt->Name();


Parent player("asdf", "zxcv", true);
Child& rr = player;		// 허용 안됨
Child* pr = player;	// 허용 안됨
```

- 파생 클래스 참조는 기초 클래스 객체를 위해 파생 클래스 메서드를 호출하는데,
- 기초 클래스는 파생 클래스의 메서드를 가지고 있지 않기 때문에 문제.

- 기초 클래스 객체를 지시하는 포인터를 형식 매개변수로 사용하는 함수에
- 기초 or 파생 클래스 객체 주소 사용 가능

```
void wohs(const Parent* pt);

Parent player1();
Child rplayer1();
wohs(&player1);		// Parent* 매개변수
wohs(&rplayer1);	// Child* 매개변수
```

- 이와 같은 참조 호환성은 기초 클래스 객체를 파생 클래스 객체로 초기화하는 것도 간접적으로 허용
```
Child olaf1();
Parent olaf2(olaf1);			// Parent(const Child&);	// 존재하지 않음
```

- 이 경우 대신 암시적인 복사 생성자가 그 역할을 대신함

```
Parent(const Parent&);
```

- 기초 클래스형에 대한 참조. 따라서 파생 클래스 형을 참조할 수 있다.

- 같은 논리로, 파생 클래스 객체를 기초 클래스 객체에 대입할 수 있다.
```
Child olaf1();
Parent winner;
winner = olaf1;		// 파생 클래스 객체를 기초 클래스 객체에 대입한다.
```

- 이 경우 다음 암시적인 오버로딩 대입 연산자 사용됨

```
Parent& operator=(const Parent&) const;
```

- 기초 클래스 참조가 파생 클래스 객체를 참조한다.
- olaf1의 기초 클래스 부분이 winner에 복사된다.




2. 상속: is-a 관계

- 기초 클래스를 대상으로 수행할 수 있는 모든 작업을, 파생 클래스 객체에 대해서도 수행할 수 있다.
- is-a-kind-of 관계. 보통 is-a 관계라 함


- has-a 관계 아님. "점심에 과일"
- is-like-a 관계 아님. "변호사는 상어다"
- i-implemented-as-a 관계 아님 "배열 - 스택"
- uses 관계 아님 "컴퓨터 - 프린트"




3. public 다형 상속

다형 (polymorhphic)

virtual 키워드
- 메서드가 객체에 의해 호출되지 않고 참조나 포인터에 의해 호출되었을 때
- 참조나 포인터에 의해 지시되는 객체형에 기초하여 메서드를 선택

예시 [생략]

가상 파괴자
- 파괴자들이 가상이 아니면, 포인터형에 해당하는 파괴자만 호출될 것
- 파괴자들이 올바른 순서로 호출되도록 한다.
- 자식에서 어떤 일을 하는 파괴자를 가질 경우, 
	- 아무 일도 하지 않는 파괴자라 하더라도 부모에 가상 파괴자를 제공해야 함




4. 정적 결합과 동적 결합
