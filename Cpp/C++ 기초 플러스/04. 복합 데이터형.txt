배열은 복합 데이터형이다.
- compound type. (c는 derrived type)

배열 미초기화 시
- 배열 원소의 값들은 미확정 상태로 남는다.
- 그 메모리 위치에 전부터 우연히 남아 있던 쓰레기들을 값으로 취한다.

크기
- strlen()은 널 문자 전까지 셈

cin
- 빈칸, 탭, 캐리지 리턴과 같은 화이트스페이스가 있으면 그 위치에서 문자열이 끝난 것으로 간주
- 즉 char[] => cin은 하나의 단어만 읽어 배열에 저장하고 널 문자를 끝에 추가

getline()
- 개행 문자를 읽어서 폐기
- cin.getline(name, 20)
- => 19개 이하 문자 저장

get()
- 입력 큐에 개행 문자를 남겨둔다.
- cin.get(name, size); cin.get(name2, size); 
- => 문제. 두 번째 호출이 개행 문자를 첫 문자로 만나 행의 끝에 도달했다고 결론내림
- cin.get(name,size); cin.get(); cin.get(name2, size);
- => ㅇㅋ
- cin.get(name, size).get();
- => ㅇㅋ.

cin.clear()
- 빈 행을 읽으면 failbit라는 것이 설정됨
- 계속되는 입력을 막고, 입력을 복원

```
#include <iostream>

int main()
{
	using namespace std;
	int year;
	cout << "연도입력: ";
	cin >> year;
	// cin.get();	// 개행 문자를 읽어 허공에다 버려야 정상 작동
	cout << "도시입력: ";
	char address[70];
	cin.getline(address, 70);
	cout << "연도: " << year << endl;
	cout << "도시: " << address << endl;
	cout << "완료!\n";
	return 0;
}
```
```
연도입력: 1
도시입력: 연도: 1
도시:
완료!
```



3. string

초기화되지 않은 데이터에서 첫 널 문자가 나타나는 위치는 본질적으로 랜덤하다.
- strlen(char[]형) 시 문자열의 길이는 배열의 크기보다도 크게 나온다.

문자열 상수 초기화 시 접두사
```
	wchar_t title[] = L"asdf";
	char16_t name[] = u"zxcv";
	char32_t car[] = U"qwer";
```

C++11
- UTF-8이라는 유니코드 문자를 위한 인코딩 방법을 지원함
- raw 문자열 지원  R"(   ~~   )"
```
	cout << R"( Jim "King" Tutt uses "\n" instead of endl . )" << '\n';
	// cout << "( Jim \"King\" Tutt uses \"\\n\" instead of endl . )" << '\n';
```
- 똑같은 문자들이 "와 ( 사이에 껴도 됨 ex. R"+*( ~~~ )+*"
```
	cout << R"+*("(who wouldn't?)", she whispered.)+*" << endl;
```




4. 구조체

구조체 안의 비트필드
- 구조체 멤버들이 각각 일정 비트 수를 차지하도록 지정
- 레지스터에 대응하는 데이터 구조 등 저수준 프로그래밍에서 주로 사용
```
struct A
{
	unsigned a : 4;
	bool b : 1;
};
```




5. 공용체

서로 다른 데이터형을 한 번에 한 가지만 보관할 수 있는 데이터 형식

```
#include <iostream>
using namespace std;

union one4all
{
	int intVal;
	long longVal;
	double doubleVal;
};

int main()
{
	one4all pail;
	pail.intVal = 15;
	cout << pail.intVal << endl;
	pail.doubleVal = 1.38;
	cout << pail.doubleVal << endl;	// double 형을 저장, int 형 값은 소실
	cout << pail.intVal << endl;
}
```
```
15
1.38
-515396076
```

크기
- 공용체의 크기 == 가장 큰 멤버의 크기
- 여러 가지 데이터형을 사용할 수 있지만 동시에 사용할 수 없을 때, 메모리 절약 가능

익명 공동체(anonymous union)은 이름이 없다.






6. 열거체

enum형의 객체는 enum 내부 열거자 값들만 대입 가능

```
#include <iostream>
using namespace std;

enum spectrum { red, orange, };

int main()
{
	spectrum band;
	band = red;
	band = 2000;	// 오류
}
```

타입
- 정수형
- int형으로 승급될 수 있다.

열거체의 값 범위
- 어떤 정수값이 그 범위 안에 들어 있으면, 그것이 열거자 값이 아니더라도
- 데이터형 변환을 통해 열거체 변수에 대입할 수 있다.

```
#include <iostream>
using namespace std;

enum bits { one = 1, two = 2, four = 4, eight = 8 };

int main()
{
	bits myflag;
	myflag = bits(6);	// 맞다. 6이 bits 범위 안에 들어있다.
	cout << myflag;
}
```

열거체의 값 상한
- 열거자 값 중 최대값보다 큰 2의 최소 거듭제곱 - 1

열거체의 값 하한
- 열거자 값 중 최소값이 0 이상이라면 0
- 열거자 값 중 최소값이 0 미만이라면,  
	ex. -6이면 6보다 큰 2의 거듭제곱 8 - 1, 여기에 마이너스 붙여 -7





7. 포인터

객체 지향 프로그래밍
- 컴파일 시간이 아닌 실행 시간에 어떤 결정을 내린다는 것을 강조

포인터 *
- 간접값(indirect value) 연산자, 간접 참조(dereferenceing) 연산자

* 위치
전통 C 프로그래밍 방식
- int *ptr;
- *ptr가 int형임을 강조

C++ 프로그래밍 방식
- int* ptr;
- int* 형 자체가 하나의 데이터형임을 강조


new - delete
```
	int jugs = 5;
	int* pi = &jugs;
	delete pi;		// new로 대입한 메모리가 아니므로 틀리다.
```

정적 바인딩(static binding)
- 프로그램이 컴파일 될 때 배열을 위한 메모리가 대입
동적 바인딩(dynamic binding)
- 프로그램을 실행하는 동안 배열의 크기 결정

널 포인터에는 delete를 사용하는 것이 안전
- 아무 일도 일어나지 않음

포인터 변수에 1을 더하면 그 포인터가 지시하는 데이터형의 바이트 수만큼 값이 증가한다.

포인터를 적당한 주소로 초기화하지 않은 상태에서 간접 참조에 사용하면 안 된다.

배열 이름에 sizeof 연산자 적용 시, 배열의 첫 번째 원소의 크기가 아니라 배열의 전체 크기가 바이트 단위로 리턴


strcpy, strlen 등 예제

```
#include <iostream>
#include <cstring>
#pragma warning(disable:4996)
using namespace std;

int main()
{
	char lion[10] = "사자";
	char* ps;
	ps = lion;

	cout << "strcpy() 사용 전 \n";
	cout << (int*)lion << ": " << lion << endl;
	cout << (int*)ps << ": " << ps << endl;

	ps = new char[strlen(lion) + 1];
	strcpy(ps, lion);

	cout << "strcpy() 사용 후 \n";
	cout << (int*)lion << ": " << lion << endl;
	cout << (int*)ps << ": " << ps << endl;
}
```
```
strcpy() 사용 전
000000A85BB2F998: 사자
000000A85BB2F998: 사자
strcpy() 사용 후
000000A85BB2F998: 사자
00000228A9B92110: 사자
```

strcpy 위험
- 배열의 크기를 벗어나는 나머지 부분을 배열에 바로 이어서 저장하기 때문에,
- 프로그램이 사용하고 있는 다른 내용을 덮어버릴 수 있다.
- strncpy() + 복사할 최대 문자수 사용
- 그러나 이 함수는 저장 공간이 바닥이 나는 경우에 널 문자를 추가하지 않는다.
- 하여, 다음과 같이 사용
```
#include <iostream>
#include <cstring>
#pragma warning(disable:4996)
using namespace std;

int main()
{
	char food[20] = "food";
	strncpy(food, "a picnic basket filled with many goodies", 19);
	cout << food << endl;
	food[19] = '\0';
	cout << food << endl;
}
```
```
a picnic basket fil
a picnic basket fil
```
// 디버깅해보니 넣어주는데..?


자동 공간, 정적 공간, 동적 공간
