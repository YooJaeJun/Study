1. integer overflow
- 정수형 변수의 오버플로우는 정수값이 증가하면서 타입이 허용하는 가장 큰 값보다 더 큰 값을 저장하려 할 때, 실제 저장되는 값이 의도하지 않은 수로 반환되는 현상
- 정수형 변수를 연산에 사용하는 경우 결과값이 범위 체크하도록 수정

2. strcpy 함수
- 두 번째 인자의 문자열을 첫 번째 인자의 문자열에 복사
- 두 번째 인자가 nullptr일 경우 개체를 가리키는 것이 없기 때문에 복사 시 컴파일 에러
- 두 번째 인자가 첫 번째 인자보다 클 경우 오버 플로우 발생.메모리를 저장할 주소가 없어 컴파일 에러.

3. 널종료문자열
- 널'\0'을 끝으로 하는 문자열

4. stack overflow
- 스택 한계보다 더 많은 크기를 스택에 쌓으려 할 때 발생하는 오류
- 주로 무한반복에서 발생



1. new T[0]; 의 사이드이펙트
0바이트 만큼 메모리 할당해도 컴파일 에러를 뱉지 않지만 추가 초기화 시 오버 플로우 발생.예외처리 필요.

2. delete[] nullptr; 의 사이드이펙트
- 비할당된 메모리 소멸 시도 시 컴파일 에러

3. 동일하지 않은 타입에 대해 함부로 연산 하지 말 것.

4. substr//좀 더 깔끔하게 짤 수 있는 방법에 대해 고려
//동적할당 하는 코드가 여러곳에 노출되는게 바람직하지 못함.
//다른 멤버 함수로 충분히 동일하고 더 안전하게 동작하게 유도할 수 있음.

5. 불필요하게 반복되는 함수 호출이 보임.


6. 사용한 표준 함수에 대해 모두 정리해서 설명.
ex) 어떤 인자를 전달했을 때, 어떤 예외상황이 발생한다거나 반환 값에 대한 설명.
strstr
- 첫 번째 인자 문자열에 두 번째 인자 문자열이 속해있는지 판단하는 함수.없으면 null을 반환.있으면 해당 포인터를 반환
- 검색에서 마지막 널 문자는 포함하지 않음
- 하여 두 번째 인자 문자열이 nullptr일 경우 검사하지 않고 null을 반환

7. yjjstring::append(const yjjstring& str); 함수 다시 작성.
- yjjstring::append(const char* null_terminated_str) 함수 호출.str.str_을 전달

8. memory_check함수
