인터페이스
	서로 다른 장치 연결

운영체제
	컴퓨터와 사용자 간의 상호교신
	시스템의 자원관리와 프로그래을 위한 인터페이스 역할
	사용자 편의성, 컴퓨터 시스템 효율적 운영

역할
	프로그램 수행
	입출력 연산
	파일 시스템 조작
	통신
		IPC - 서로 다른 프로세스 통신
	오류 탐지

시스템
	자원할당
	Accounting
		모니터링
	보호

기능
	프로세스관리
		프로세스의 생성과 제거
		(중요)스케쥴링
		(중요)교착상태 방지 4-4 가지
	보조기억장치관리
	파일관리
	장치관리
	메모리관리
	시스템보호
		세마포어
	네트워킹
	명령어 해석
		커널 - 운영체제의 핵심

부트로더
	바이오스 - 컴퓨터 하드웨어 설정 담당
	바이오스 실행 - 자체 진단 - 적재 등등

UFFI
	Fast Booting 지원 위한 애플리케이션

커널
	하드웨어 접근 인터페이스를 통해 응용sw가 hw 자원을 사용할 수 있도록 서비스 제공
	보안, 자원관리 등

시스템 콜
	사용자에게 커널 레벨의 작업을 수행하도록 하는 인터페이스/함수
	커널 모드 / 사용자 모드
	종류
		Sleep(), fclose() 등

프로세스
	exe 파일 실행 시, 메모리에 로드되어 CPU에 의해 실행 중인 프로그램
	레지스터, 스택, 포인트, 프로그램, 데이터 등의 집합체로 실행 중인 프로그램 인스턴스
		실제로는 하나의 프로그램에 여러 프로세스
		엔트리 포인트 - 진입접 - main 함수
	멀티태스킹 os는 프로세스 개념을 바탕으로 동작

스택 프레임
	함수 하나의 스택 구역

프로세스 상태
(그림 참고)
	생성 중
		cpu 할당 안 된 상태
	실행상태
		Time run out 이라는 시간 주기 내 작업 끝나지 않으면 인터럽트를 발생시킴
	대기상태
		인터럽트 등으로 대기상태
		Wake up : 다른 작업 끝났을 때, 프로세스가 준비상태로 전이

PCB
	프로세스 컨트롤 블럭
	커널의 자료 구조
	모든 프로세스는 PCB를 모두 가지고 있다.
	컨텍스트 스위칭은 PCB를 교체하는 과정
	메모리(코드,데이터,힙,스택) 중 PCB가 가장 위에 있다.

PCB 구성
	PID
	프로세스 상태
	프로그램 카운터
	레지스터 저장 영역
	프로세서 스케줄링 정보
	계정 정보
	입출력 상태 정보
	메모리 관리 정보

프로세스 스케줄링 큐
	프로세스 스케줄링을 위해 운영체제가 여러 종류의 큐를 유지
	링크드 리스트로 구현
	잡 큐 / 레디 큐 / 디바이스 큐 / 웨이팅 큐
	레디 큐 - Ready 상태
	웨이팅 큐 - Waiting 상태


컨텐스트 스위칭
	비자발적
		실행->준비
		타임 슬라이스 소진 시
		인터럽트 발생 시
	자발적
		실행->대기
		Sleep
		Exit
		Wait

컨텍스트 스위칭 최소화 방안
	다중 프로그래밍 최소화
	스택 포인터를 변경
	스레드 이용

IPC
	프로세스 간 데이터 통신
	파이프, 메시지, 공유 메모리

스레드
	Light Weight 프로세스
	메모리 영역 공유
	실행 단위: 함수 단위
	커널 영역
	사용자 영역

멀티 스레드
	힙, 데이터, 코드 공유
	스택만 각 스레드에서 관리
	IPC 발생하지 않음

TCB는 링크드 리스트 기반

프로세스 vs 스레드
	스레드										프로세스
	CPU를 기본 작업 단위로(함수 단위)				자원 할당을 위한 기본 구분 단위(.exe)
	CPU 성능 향상, 시스템자원 활용 극대화			순차적 실행, 실행 순서를 알 수 있음
	실행 순서를 모름								컨텍스트 스위칭으로 인한 부하

인터럽트
	외부
		전원 이상, 기계 착오, 외부 신호(타이머, 키보드 등), 입 출력
	내부
		프로그램 검사 - 0으로 나누기, 오버플로, 언더플로
	SW
		SVC(Supervisor Call) 명령으로 의도적 인터럽트	Sleep 함수 등


CPU 스케줄링
		선점									비선점
개념	현 프로세스 중지							선점 불가
장점	비교적 빠른 응답							응답시간 예상 용이
		대화식 시분할 시스템						모든 프로세스 요구 공정하게 처리
단점	높은 우선순위 프로세스들, 오버헤드		짧은 작업 수행하는 프로세스가 긴 작업 종료 시까지 대기
알고	RR / SRT / 다단계 큐 / 다단계 피드백 큐	FCFS / Priority / Deadline / SJF / HRN
활용	실시간 응답환경							처리시간 편차 적은 특정 프로세스 환경

알고리즘
선점
	RR  Round Robin
		FCFS + time Slice
	SRT  Short Remaining Time
		준비 큐에서 대기하는 프로세스 중, 
		잔여 실행 시간이 가장 짧은 거승로 예상되는 프로세스를 우선 처리
	MLQ  Multi Level Queue
		작업들을 여러 그룹 분할
		준비 큐는 개별적인 큐로 분할
	MFQ  Multi Level Feedback Queue
		CPU Time Slice(Quantum)을 부여
		새 프로세스는 높은 우선순위, 
		프로세스의 실행 시간이 길어질수록 점점 낮은 우선순위 큐로 이동

	결과 - 평균대기시간 / 반환시간 / 평균반환시간

비선점
	FCFS  First Come First Served
	우선순위
	Deadline
		예측 어려움
	SJF	Short Job First == SPF
		준비 큐 내 작업 중 실행시간이 가장 짧다고 예상되는 것 먼저 수행
	HRN  Highest Response Ratio Next
		우선순위를 서비스 대기시간도 계산
		SPF의 약점 보완 기법
		우선순위 = (대기시간 + 서비스 시간) / 서비스 시간


우선순위 역전
	비선점에서 발생
	준비 상태 바뀌어도 더 낮은 우선순위 태스크가 CPU 점유하고 있어 실행되지 못함

Process 동기화
	병행 처리 문제
		상호 배제
		동기화 문제
		통신 문제
		교착상태문제
	Race Condition
		두 개 이상 명령어가 동시에 같은 기억 장소 액세스 시,
		그들 사이 경쟁에 의해 수행 결과를 예측할 수 없는 상태
	임계영역
		둘 이상 프로세스가 공유할 수 없는 자원을 임계자원
		프로그램에서 임계자원을 이용하는 부분
	상호배제 Mutual Exclusive
		임계영역 내에서, 시스템이 어떠한 자원을 한 시점에서
		한 개의 프로세스만이 사용할 수 있도록 하는 것
		기법 - 세마포어

Race Condition
	동시에 같은 자원을 2개 이상의 프로세스가 경쟁적으로 사용하려는 상황
	해결 요구 조건
		상호배제 조건
			둘 이상의 프로세스들이 동시에 임계영역에 있어선 안됨
		한계 대기 조건
			어떤 프로세스도 임계 구역으로 들어가는 것이 무한정 연기되선 안됨
		진행 조건
			임계영역 밖에 있는 프로세스가 다른 프로세스의 임계영역 진입을 막아선 안됨

	해결기법
		세마포어 / 상호배제 최소화 / 최소 임계영역 / Busy wait 통한 시간 제한

임계영역
				크리티컬 섹션					뮤텍스			세마포어
동기화 객체		유저모드								커널모드		
특징			쓰레드 동기화, 가볍고 고속		프로세스/쓰레드 모두 사용 가능, 저속
Wait			Enter~							Wait			P 연산
Signal			Leave~							Mutex			V 연산


뮤텍스
	한 자원에 한 스레드만 접근

세마포어
	한 자원에 여러 스레드 접근 가능
	S - 정수 값
	P 연산
	V 연산
	P는 임계 구역에 들어가기 전 수행, V는 임계 구역에서 나올 때 수행

바쁜 대기 방법
	P(S) {
		while S <= 0;	// 아무 것도 안 함. 비효율
		S--;
	}

	V(S) {
		S++;
	}

Sleep Queue 이용 방법
	P(S) {
		S--;
		if S < 0
			// 이 프로세스를 재움 큐에 추가 == 잠듦
	}

	V(S) {
		S++;
		if S <= 0
			// 재움 큐로부터 프로세스를 제거 == 깨어남
	}

모니터
	세마포어의 타이밍 문제 해결

교착상태
	서로 상대방의 자원을 요구하면서 양쪽 모두 작업수행을 할 수 없는 대기상태

교착상태 발생 조건 4가지
	상호배제
		프로세스가 자원을 배타적으로 점유하여, 다른 프로세스가 그 자원 사용 불가
	점유 대기
		한 프로세스가 자원을 점유하고 있으면서, 또 다른 자원을 요청하여 대기
	비선점
		한 프로세스가 점유한 자원을 다른 프로세스가 선점할 수 없고,
		오직 점유한 프로세스만이 해제 가능
	환형대기
		둘 이상 프로세스 간 자원의 점유와 대기가 하나의 원형을 구성

교착상태 해결 방안 4가지
	예방
		상호배제를 제외한 나머지 교착 상태 발생조건을 부정
		점유 자원 해제 후 새 자원 요청
		4가지: 상호배제부정, 점유대기부정, 비선점부정, 순환대기부정
	회피
		안전한 상태를 유지할 수 있는 요구만 수락
		은행원 알고리즘 : 안전 상태인 경우만 자원 할당, 비안전-대기
	발견
		시스템 상태 감시 알고리즘을 통해 교착상태 검사
		자원할당 그래프
	회복
		데드락이 없어질 때까지 프로세스를 순차적으로 킬
		희생자 선택, 기아상태 발생가능
		프로세스 킬, 자원선점

자원할당 그래프
	노드와 간선 방향성 그래프
	자원 할당 사항과 요구 사항을 표현


운영체제
주기억장치 관리
	메모리 공간을 프로세스들에게 할당하고 회수하는 기법
	바인딩
		실행할 프로그램, 데이터를 주기억장치의 특정 물리적 주소에 지정
	가상주소
		논리적 주소. 보조기억장치에 적재

우리가 관리할 곳은 힙 영역

관리정책
	반입, 배치, 교체, 할당

반입정책
	요구, 예상

배치정책
	동적할당(가변)에서만 사용

	최초적합(first-fit)
	최적적합(best-fit)
	최악적합(worst-fit)
	다음적합(next-fit)

교체정책
	FIFO
	LFU  Least Frequently Used
		가장 참조 횟수가 적은 페이지 교체. 최근 사용 안 함
	LRU  Leat Recently Used
		가장 오래 동안 사용되지 않은 페이지 제거

할당 정책
	연속 할당
		물리적 메모리의 한곳에 연속적으로 적재

		고정분할
			물리적 메모리를 고정크기로 분할
		가변분할 (최초, 적합, 최악)

	불연속 할당
		페이지 또는 세그먼트로 나누어 주기억장치 내 분산 배치
		가상 메모리

		페이징
			동일한 크기의 페이지로 잘라 적재
				페이지 하나당 스택or코드or데이터 영역 일 수도 있음
		세그먼테이션
			코드, 데이터, 스택 등 의미 있는 단위인 세그먼트로 나누어 적재
				스택/코드/데이터 영역이 세그먼트 내에 나누어져 있음
		페이지드 세그먼테이션
			세그먼트 하나를 다수의 페이지로 구성

단편화
	사용되지 못하고 낭비되는 부분적인 기억 공간
	내부 단편화
		하나의 분할에 작업을 할당하고 남은 빈 공간
	외부 단편화
		대기중인 작업에게는 분할이 너무 적어 분할체가 빈 공간으로 있을 때의 상태

단편화 해결기법
	통합
		인접한 하나의 공백으로 합침
	압축
		산재된 모든 공백 하나의 공백으로 합침

페이지 교체 정책
	LRU, LFU 는 현재 시점
	OPT 는 앞으로. 가장 오랫동안 사용하지 않을 페이지 교체

FIFO ANOMALY (Belady's Anomaly)
	페이지 폴트 page fault
		주기억장치에서 발생 시 보조기억장치로 내려가 찾는다.
		CPU - Cache - M/M (메모리 page에서 찾았을 때 없으면 페이지 폴트)  -  S/M
	페이지 프레임 개수를 늘렸는데도 page fault 발생 증가
	Locality를 고려하지 않은 교체 정책은 스레싱 발생 증가
		스레싱 : 페이지 폴트 많아 CPU에 부하가 발생하는 현상

가상 메모리
	윈도우는 페이징 기반
	virtualalloc - 64KB
	메모리 주소공간으로 기억
	가상기억장치에는 연속적이어도, 주기억장치에서는 불연속적인 실제 주소
	사상 == 매핑
	주소 사상 => 페이지 테이블
	
스레싱
	페이지 교체 -> 프로세스 처리 저하
	리소스 부족 / 부적절한 페이지 교체 정책 / 과도한 멀티 프로세싱
	
	해결
		Working-Set Model - 시간적 지역성을 이용, 많이 참조하는 페이지 집합을 Working-Set으로 구성
		Page Fault Frequency - 페이지 부재의 상/하한을 결정, 프레임 개수 조절
		프리 페이징 / 멀티 프로그래밍 정도 감소 / 메모리 증설




