설계를 위함


캡슐화
	묶어놓고, 필요한 기능만 제공
정보은닉
	필요한 부분만 외부에서 접근할 수 있게 공개

어트리뷰트(멤버변수)는 메서드를 통해서만 변경하도록.

객체지향 특징 - 용어정리
추상화
	비슷한 클래스 간 다른 행동들을 이름상으로 공통으로 묶기
	설계 단계의 추상 개념과 헷갈리지 않을 것
		설계 단계의 추상화 : 현실세계 특정 측면 강조
		객체 지향의 추상화 : 다른 행동들, 공통 이름 묶기
			이름 통합->관리 쉬움
			인터페이스->결합도 낮춤

다형성
	같은 이름으로 서로 다른 행위
	다양한 형태를 갖는 성질
	오버라이딩

컴파일러가 함수 구분 시, 
	C - 함수 이름 
	C++ - 함수 파라미터
		리턴 타입 변경해도 (int Add() / string Add())		같은 함수로 인식함
	참고) 링크 에러 나도 리턴 타입이 나오지 않음

'''
#include <iostream>
using namespace std;

class A
{
public:
	int a = 5;
};

class B : public A
{};

class C : public A
{};

class D : public B, public C
{};

int main()
{
	D d;
	d.a = 5;	// 에러: 모호	// static 변수이거나, 다중상속 받지 않거나.
	d.B::a = 5;

	return 0;
}
'''

특수화 (실체화) vs 일반화

추상클래스 vs 인터페이스

인터페이스
	재정의 해야 할 요소들만 가지고 있다.
	서로 다른 타입끼리 한 기능 공유
		이름 통일
	언리얼에서 가상 함수 가능
	변수
		상수(static final)만 가능
	함수
		가상만 가능
	구현 : Implements (자바기준)

추상클래스
	가상 함수 - 자식 클래스에서 반드시 재정의
	일반 변수 가능
	구현 : Extends (자바기준)


SOLID
	객체지향방법론이 지향하는
	재사용과 유지보수 극대화 달성을 위한
	클래스 단위에서의 설계 원칙
단일책임
	
개방폐쇄
	Open - 클래스 확장은 상속
	Closed
	변하지 않을 것들은 인터페이스로
	서로 영향 최소화
리스코프 치환
	부모 코드를 자식으로 모두 내려도, 동작 가능해야 함
	무분별한 상속과 다중상속 방지
인터페이스 분리
	인터페이스 쪼개기
	서로 간 연결 편하게 
의존관계 역전
	추상 - 파생클래스 것 참조 하면 안됨
	클래스 개수 최소화


UML
	공용설계언어
	도해만 보자
클래스 다이어그램
관계
	의존 / 연관 / 일반화/ 실체화 관계
	Aggregation 집합관계
		반드시 필요하지 않은 상황
		0 .. 1 표기
		0은 가질 수도 있고 안 가질 수도
	Composition 복합관계
		반드시 필요
	
유즈케이스 다이어그램
	어떻게 흘러갈지 명세
	게임쪽에선 사용 어려움

시퀀스 다이어그램
	객체 간 메시지 순서를 시간의 흐름에 따라 보여줌
	동기 / 반환 / 비동기 / 평판



