malloc new
	바이트 단위, 크기 단위

언더 플로우
	지워졌는데 또 지움

static
	전역
		컴파일이 완료되었을 때 생성
	지역
		호출 시점에 생성

auto
	멀티 컴파일 시 위험

int const * const a = ~;

#define Add(a, b) (a) (b)

패딩
	바이트를 일정 간격으로 끊기 위해 사용
	네트워크 위함 : 데이터 소모량 최소화

공용체
	같은 주소를 이름을 다르게 쓰기 위함

virtualalloc
	공간 예약
	빈 공간 잡아서 못 들어오게

스택 프레임
	함수 호출 시 2MB 정도의 스택 공간

EBP == ESP 시점
	스택의 파괴

cdecl
	Caller에서 정리
	가변인자 함수 가능
	vaarg
stdcall
	Callee에서 정리

thiscall
	this포인터 call
	TSharedPtrFromThis

컴파일 과정
	전처리기
		헤더, define, 전역변수 처리

	(언리얼 컴파일러)
	컴파일러
	링크
		라이브러리 파일을 lnk파일로
		결합해 exe 파일로

인터프리터 언어
	한 줄 한 줄씩 읽음
	보통 스크립트 언어 - 파이썬, 루아, 루비 등

C# C++
	C++
		메모리 관리 자유로움, 메모리 즉시 제거
		컴파일 언어 속도 빠름

부동소수점 오차
	정해진 바이트 안의 소수점을 쪼개서 계산하기 때문
	비트 연산과 관련해 조사

float <-> 문자열로
	언리얼 소스 코드 참고

부동소수점 장단점
	중요도는 낮음

허상 포인터
	가리키는 메모리 제거됨	
	dynamic cast 실패 시 부모 공간 사이즈는 알고 있지만, 자식 공간 사이즈 모르기 때문

함수 포인터
	결합도를 낮출 수 있음

델리게이션
	함수 포인터는 1 : 1
	델리게이션은 1 : n 가능
	직렬화, 함수 포인터에 대한 관리 기능 포함

CallBack
	static LRESULT CALLBACK WndProc()
		윈도우 메시지 받아서 처리
	함수 포인터의 일종
	객체를 딴 데 주고, 자신의 함수를 특정 상황마다 Call


------------------------------------------------------------

템플릿
	컴파일 타임

특수화
	특정 자료형에 대해선 템플릿화 하지 않겠다.

클래스 템플릿
	상속 class A : public Test<A>
		template<typename T>
		class Test
		{
			static T Get() {}
		}
		부모의 static 영역 접근
		자식이 특정 타입을 알고 싶을 때

inline 함수
	점프할 내용을 미리 복사
	_inline
	__inline
	종류, 내용, 동작방법 정리
	언리얼 FORCEINLINE

캡슐화
	구현 자체를 비공개 = 블랙박스화
	정보은닉과 달리, 입력과 출력은 공개하되, 
		내부동작은 비공개
다운캐스팅
	dynamic_cast

추상화
	부모를 정의하는 시점에선 ~~~~
	부모에서는 선언만 두는 형태
	c에서는 순수가상함수로 구현

가상
	부모에서 이미 정의된 기능을 재정의
추상
	부모에서 정의되어 있지 않은 기능을 자식에서 구현

추상 클래스
	객체화 할 수 없음

6가지
복사, 이동 차이
	메모리를 기존 것을 유지하느냐, 아니냐
	
이동 move
	메모리 이동 안 함

얕은/깊은 구현
	복사 생성자, 대입연산자에서 함

복사 생성자 호출 조건
	같은 클래스의 객체로 초기화
	함수의 파라미터가 call by value로 넘어올 때, 리턴될 때

가상화
	동적할당
	부모에서 가상함수 하나 이상
	가상소멸자만 부모 콜	

가상함수 테이블
	부모 클래스 영역에 존재함!
	상속 시 자식 클래스에 부모 클래스 영역에 별도로 존재
	b.A::name = "aaa";

인터페이스
	서로 다른 객체들끼리 그룹군 형성

RTTI
	type-id 기반 - 해당 타입에 대한 해시 자료형

	int a = 10;
	float b = (float)a;
	float c = static_cast<float>(a);

	컴파일 시 체크 / 런타임 시 체크

C++/CX
	MS 문서 참고
	표준 C++과 달리, 
	static_cast 가 런타임 검사 수행함

reinterpreter
	포인터 형 변환
	댕글링 포인터 발생
	우리가 일반적으로 사용 x. 임베디드에서 매핑 시간 줄이기 위해 사용

멀티 프로그래밍
프로세스
	PCB
		자기의 메모리 영역 하나
			메모리 영역 = 코드, 데이터, 스택, 힙
	
IPC
	프로세스 간 통신
	4가지 방식
	IO 거침 - 인터럽트 발생시키기 때문에 느리다.

CCB
	프로세스를 모방, 작은 단위인 스레드 만듦
	스레드끼리 같은 메모리 구역
	함수 단위

공유 자원 문제 발생
	레이스 컨디션
		서로 간 자원 경쟁
	프로세스가 누가 들어갈 거냐 - 스케줄링
	선점형 / 비선점형
		라운드 로빈, SJF 등
OS - 뮤텍스, 세마포어
	뮤텍스 == 상호배제
		Lock / Unlock
	세마포어
		한 곳에 여러 프로세스
		카운팅으로 조절
데드락
	발생 / 회피 / 예방 조건 4가지
모니터 알고리즘
	감시

