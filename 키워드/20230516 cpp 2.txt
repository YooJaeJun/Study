템플릿
	컴파일 타임

특수화
	특정 자료형에 대해선 템플릿화 하지 않겠다.

클래스 템플릿
	상속 class A : public Test<A>
		template<typename T>
		class Test
		{
			static T Get() {}
		}
		부모의 static 영역 접근
		자식이 특정 타입을 알고 싶을 때

inline 함수
	점프할 내용을 미리 복사
	_inline
	__inline
	종류, 내용, 동작방법 정리
	언리얼 FORCEINLINE

캡슐화
	구현 자체를 비공개 = 블랙박스화
	정보은닉과 달리, 입력과 출력은 공개하되, 
		내부동작은 비공개
다운캐스팅
	dynamic_cast

추상화
	부모를 정의하는 시점에선 ~~~~
	부모에서는 선언만 두는 형태
	c에서는 순수가상함수로 구현

가상
	부모에서 이미 정의된 기능을 재정의
추상
	부모에서 정의되어 있지 않은 기능을 자식에서 구현

추상 클래스
	객체화 할 수 없음

6가지
복사, 이동 차이
	메모리를 기존 것을 유지하느냐, 아니냐
	
이동 move
	메모리 이동 안 함

얕은/깊은 구현
	복사 생성자, 대입연산자에서 함

복사 생성자 호출 조건
	같은 클래스의 객체로 초기화
	함수의 파라미터가 call by value로 넘어올 때, 리턴될 때

가상화
	동적할당
	부모에서 가상함수 하나 이상
	가상소멸자만 부모 콜	

가상함수 테이블
	부모 클래스 영역에 존재함!
	상속 시 자식 클래스에 부모 클래스 영역에 별도로 존재
	b.A::name = "aaa";

인터페이스
	서로 다른 객체들끼리 그룹군 형성

RTTI
	type-id 기반 - 해당 타입에 대한 해시 자료형

	int a = 10;
	float b = (float)a;
	float c = static_cast<float>(a);

	컴파일 시 체크 / 런타임 시 체크

C++/CX
	MS 문서 참고
	표준 C++과 달리, 
	static_cast 가 런타임 검사 수행함

reinterpreter
	포인터 형 변환
	댕글링 포인터 발생
	우리가 일반적으로 사용 x. 임베디드에서 매핑 시간 줄이기 위해 사용

멀티 프로그래밍
프로세스
	PCB
		자기의 메모리 영역 하나
			메모리 영역 = 코드, 데이터, 스택, 힙
	
IPC
	프로세스 간 통신
	4가지 방식
	IO 거침 - 인터럽트 발생시키기 때문에 느리다.

CCB
	프로세스를 모방, 작은 단위인 스레드 만듦
	스레드끼리 같은 메모리 구역
	함수 단위

공유 자원 문제 발생
	레이스 컨디션
		서로 간 자원 경쟁
	프로세스가 누가 들어갈 거냐 - 스케줄링
	선점형 / 비선점형
		라운드 로빈, SJF 등
OS - 뮤텍스, 세마포어
	뮤텍스 == 상호배제
		Lock / Unlock
	세마포어
		한 곳에 여러 프로세스
		카운팅으로 조절
데드락
	발생 / 회피 / 예방 조건 4가지
모니터 알고리즘
	감시



